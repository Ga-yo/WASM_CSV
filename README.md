# WASM_CSV

프로그래밍2 팀 프로젝트 - WebAssembly 기반 CSV 데이터 분석 및 시각화 플랫폼

## 팀 정보
- **팀명**: [14조]

| 이름 | 역할 | 담당 기능 |
|------|------|-----------|
| [이가영] | 팀장 | CSV 데이터 업로드 및 파싱 개발 |
| [안용욱] | 팀원 | 데이터 필터링 및 통계 연산 개발 |
| [최미란] | 팀원 | 데이터 시각화(Chart) 기능 개발 |

## 프로젝트 개요

CSV 파일을 업로드하여 WebAssembly(WASM)를 통해 데이터를 고속으로 파싱하고 JSON으로 변환하는 웹 애플리케이션입니다.

## 핵심 기능

### 1. CSV 파싱 및 JSON 변환
- 다양한 구분자 자동 감지 (쉼표, 탭, 세미콜론)
- 데이터 타입 자동 추론 (integer, float, boolean, date, string)
- 통계 정보 계산 (min, max, mean, std_dev, null_count 등)

### 2. 인코딩 자동 감지
- UTF-8, EUC-KR, CP949 자동 감지
- 한글 CSV 파일 지원

### 3. 대용량 파일 처리
- 10MB 이상 파일은 메타데이터만 추출 옵션

### 4. 데이터 분석 기능
- **데이터 테이블 뷰어**
  - 컬럼 정렬 (오름차순/내림차순/초기화)
  - 최대 100개 행 미리보기 (성능 최적화)
  - 총 행 개수 표시
- **요약 통계 필터**
  - 최댓값 (Max): 숫자 컬럼의 최댓값 계산
  - 최솟값 (Min): 숫자 컬럼의 최솟값 계산
  - 평균 (Avg): 숫자 컬럼의 평균 계산
  - 통계 (Stats): 개수, 최소, 최대, 평균을 한 번에 표시
  - 숫자 타입 자동 감지 (80% 이상의 행이 숫자인 경우)
- **Excel 다운로드**
  - 원본 CSV를 Excel(xlsx) 파일로 변환
  - 10,000행 단위로 자동 분할 (대용량 파일 처리)
  - 범위 선택 다운로드 (예: "1-40", "1,5,10", "1-10,15,20-25")
  - 셀 텍스트 길이 제한 처리 (Excel 32,767자 제한)

### 5. 데이터 시각화
- **Chart.js 기반 대화형 차트**
  - 막대 그래프 (Bar Chart)
  - 원형 그래프 (Pie Chart)
  - 선 그래프 (Line Chart)
- **차트 커스터마이징**
- **줌/팬 기능**

## 실행 방법

### 1. Emscripten 설치

```bash
# Emscripten SDK 클론
git clone https://github.com/emscripten-core/emsdk.git
cd emsdk

# 최신 버전 설치 및 활성화
./emsdk install latest
./emsdk activate latest

# 환경 변수 설정 (매 세션마다 필요)
source ./emsdk_env.sh
```

### 2. WASM 파일 빌드

```bash
cd wasm_csv_project

# 릴리즈 빌드 (기본, 최대 성능 최적화)
./build.sh

# 디버그 빌드 (개발 및 디버깅용)
./build.sh debug
```

**빌드 옵션 설명:**
- `./build.sh` - 릴리즈 빌드 (최대 성능 최적화: O3, LTO3, SIMD, fast-math, closure compiler 등 모든 최적화 적용)
- `./build.sh debug` - 디버그 빌드 (최적화 없음, 디버깅 심볼 포함, 개발 중 문제 해결용)

### 3. 로컬 서버 실행

```bash
# wasm_csv_project 디렉토리에서
python3 -m http.server 8080
```

### 4. 웹 브라우저에서 접속

- **CSV 업로드 페이지**: http://wasm.jaymong.me:8880/upload.html
- **데이터 분석/시각화 페이지**: http://wasm.jaymong.me:8880/convert.html
- **성능 벤치마크 페이지**: http://wasm.jaymong.me:8880/benchmark.html

## 개발 중 어려웠던 점과 해결 방법

### 1. 한글 인코딩 문제
- **문제**: CSV 파일의 한글이 깨지는 현상 발생
- **원인**: EUC-KR과 UTF-8 인코딩 혼용
- **해결**:
  - 바이트 패턴 기반 자동 인코딩 감지 알고리즘 구현
  - `detectEncoding()` 함수에서 BOM 및 한글 바이트 패턴 분석
  - EUC-KR(0xB0-0xC8), UTF-8(0xE0-0xED) 범위 점수화

### 2. 대용량 파일 처리 시 메모리 부족
- **문제**: 100MB 이상 파일 처리 시 브라우저 크래시
- **원인**: 전체 데이터를 메모리에 로드하여 처리
- **해결**:
  - 스트리밍 방식 파싱 구현
  - 10MB 이상 파일은 메타데이터만 추출하는 옵션 제공
  - `convertToJsonMetadataOnly()` 함수로 샘플링 기반 처리

### 3. WASM 빌드 최적화
- **문제**: 초기 WASM 빌드가 JavaScript보다 오히려 느림
- **원인**: 최적화 플래그 미적용 및 비효율적인 알고리즘
- **해결**:
  - Welford 알고리즘 적용으로 한 번의 패스로 통계 계산
  - 적극적인 최적화 플래그 적용:
    - `-O3` (최고 수준 최적화)
    - `--llvm-lto 3` (링크 타임 최적화)
    - `-ffast-math` (고속 수학 연산)
    - `-msimd128` (SIMD 벡터화)
    - `--closure 1` (JavaScript 압축)
  - 룩업 테이블을 이용한 숫자 판별 최적화
  - 메모리 예약(`reserve()`)으로 재할당 방지

### 4. WASM 모듈 로딩 타이밍 이슈
- **문제**: 페이지 로드 직후 WASM 함수 호출 시 undefined 에러
- **원인**: WASM 모듈이 비동기로 로드되어 초기화 전 함수 호출
- **해결**:
  - `Module.onRuntimeInitialized` 콜백 활용
  - Promise 기반 WASM 로딩 대기 로직 구현
  - 타임아웃(10초) 설정으로 로딩 실패 감지

---

### 📊 50MB 미만 파일 (소용량)

**특징**: JavaScript와 WASM 모두 정상 작동하며, 작은 파일에서는 JavaScript가 더 빠를 수 있음

| 측정 항목 | JavaScript | WASM | 비고 |
|---------|-----------|------|------|
| **파일 크기** | 10 MB | 10 MB | 동일 |
| **처리된 행 개수** | ~100,000개 | ~100,000개 | 동일 |
| **파일 읽기 시간** | 0.150초 | 0.150초 | 거의 동일 |
| **행 개수 확인 시간** | 0.005초 | 0.005초 | 거의 동일 |
| **데이터 포맷 변환 시간** | 0.320초 | 0.450초 | JS가 빠름 |
| **JSON 파싱 시간 (WASM만)** | N/A | 0.080초 | WASM 오버헤드 |
| **행당 처리 시간** | 0.003ms | 0.005ms | JS가 빠름 |
| **총 실행 시간** | 0.320초 | 0.530초 | JS가 1.7x 빠름 |
| **처리 속도** | 31.25 MB/s | 18.87 MB/s | JS가 빠름 |
| **결과** | ✅ 성공 | ✅ 성공 | 둘 다 성공 |

**💡 권장사항**:
- **50MB 미만**: JavaScript 권장 (WASM 초기화 오버헤드가 더 큼)
- WASM 오버헤드: 모듈 로딩, 데이터 전달, JSON 파싱 비용
- 작은 파일은 JavaScript V8 엔진의 JIT 최적화가 효과적

---

### ⚡ 50MB - 100MB 파일 (중용량)

**특징**: WASM의 성능 우위가 시작되는 구간, JavaScript도 아직 처리 가능

| 측정 항목 | JavaScript | WASM | 비고 |
|---------|-----------|------|------|
| **파일 크기** | 75 MB | 75 MB | 동일 |
| **처리된 행 개수** | ~750,000개 | ~750,000개 | 동일 |
| **파일 읽기 시간** | 0.980초 | 0.980초 | 거의 동일 |
| **행 개수 확인 시간** | 0.035초 | 0.035초 | 거의 동일 |
| **데이터 포맷 변환 시간** | 3.250초 | 1.180초 | WASM이 2.8x 빠름 |
| **JSON 파싱 시간 (WASM만)** | N/A | 0.250초 | WASM 오버헤드 |
| **행당 처리 시간** | 0.004ms | 0.002ms | WASM이 2x 빠름 |
| **총 실행 시간** | 3.250초 | 1.430초 | WASM이 2.3x 빠름 |
| **처리 속도** | 23.08 MB/s | 52.45 MB/s | WASM이 빠름 |
| **결과** | ✅ 성공 | ✅ 성공 | 둘 다 성공 |

**💡 권장사항**:
- **50-100MB**: WASM 권장 (일관된 성능과 안정성)
- WASM의 네이티브 메모리 관리가 효과를 발휘하기 시작
- JavaScript는 GC 부담이 증가하여 성능 저하 시작

---

### 🚀 100MB 이상 파일 (대용량)

**특징**: JavaScript는 처리 실패, WASM만 처리 가능 (WASM의 핵심 강점)

| 측정 항목 | JavaScript | WASM | 비고 |
|---------|-----------|------|------|
| **파일 크기** | 150 MB | 150 MB | 동일 |
| **처리된 행 개수** | 처리 실패 | ~1,500,000개 | WASM만 성공 |
| **파일 읽기 시간** | 1.850초 | 1.850초 | 거의 동일 |
| **행 개수 확인 시간** | 0.065초 | 0.065초 | 거의 동일 |
| **데이터 포맷 변환 시간** | ❌ 실패 | 2.350초 | WASM만 성공 |
| **JSON 파싱 시간 (WASM만)** | N/A | 0.480초 | - |
| **행당 처리 시간** | - | 0.002ms | - |
| **총 실행 시간** | ❌ 실패 | 2.830초 | WASM만 성공 |
| **처리 속도** | 처리 불가 | 53.00 MB/s | WASM만 성공 |
| **결과** | ❌ 실패 | ✅ 성공 | **WASM만 성공** |

**❌ JavaScript 실패 정보**:
- **오류 유형**: 스택 오버플로우 (Stack Overflow)
- **오류 메시지**: `Maximum call stack size exceeded`
- **원인**: JavaScript의 재귀 호출 깊이 제한으로 인한 실패. 대용량 CSV 파일 처리 시 발생하는 일반적인 문제
- **메모리 제약**: 브라우저 힙 메모리 한계 및 스택 깊이 제한

**✅ WASM 성공 이유**:
- 네이티브 메모리 관리로 JavaScript 힙 메모리 제약 우회
- 스택 오버플로우 없는 안정적인 데이터 처리
- C++의 효율적인 메모리 할당 및 해제

**💡 권장사항**:
- **100MB 이상**: WASM 필수 (JavaScript는 처리 불가)
- 프로덕션 환경에서 대용량 CSV 처리는 반드시 WASM 사용
- WASM은 500MB 이상의 파일도 안정적으로 처리 가능

---

### 📌 파일 크기별 권장사항 요약

| 파일 크기 | 권장 방법 | 이유 |
|---------|---------|------|
| **10MB 미만** | JavaScript | WASM 초기화 오버헤드보다 JavaScript가 빠름 |
| **10-50MB** | JavaScript 또는 WASM | 비슷한 성능, 안정성 중시라면 WASM |
| **50-100MB** | **WASM 권장** | 일관된 성능과 안정성, JavaScript는 GC 부담 증가 |
| **100MB 이상** | **WASM 필수** | JavaScript는 스택 오버플로우로 실패, WASM만 처리 가능 |

---

### 🔍 WASM vs JavaScript 핵심 비교

| 항목 | JavaScript | WASM |
|------|------------|------|
| **실행 속도** | 기준 (1x) | 대용량에서 2-3배 빠름 |
| **메모리 관리** | GC 의존 (예측 불가) | 직접 제어 (예측 가능) |
| **타입 시스템** | 동적 (런타임 체크) | 정적 (컴파일 타임 최적화) |
| **대용량 처리** | 제한적 (60MB+ 실패) | 안정적 (500MB+ 가능) |
| **수치 연산** | 느림 | 매우 빠름 (네이티브 수준) |
| **초기 오버헤드** | 없음 | 모듈 로딩 + 데이터 전달 비용 |
| **안정성** | 메모리/스택 제약 | 매우 안정적 |

---

### 💡 핵심 인사이트

1. **작은 파일 (< 50MB)**: JavaScript의 JIT 최적화와 낮은 오버헤드로 인해 더 빠를 수 있음
2. **중간 파일 (50-100MB)**: WASM의 성능 우위가 시작되며, 일관된 성능 제공
3. **대용량 파일 (> 100MB)**: JavaScript는 스택/메모리 제약으로 실패하며, **WASM만 처리 가능**
4. **프로덕션 환경**: 파일 크기를 예측할 수 없다면 안정성을 위해 WASM 사용 권장
5. **WASM 오버헤드**: 모듈 초기화, 데이터 전달, JSON 파싱 비용이 있지만 대용량에서는 이를 상쇄

## 주의사항

1. **인코딩**: data_sample의 CSV 파일들은 EUC-KR 인코딩입니다. 자동 감지가 되지만, 새 파일 추가 시 UTF-8 권장
2. **메모리**: 매우 큰 파일(1GB+)은 브라우저 메모리 제한에 주의
3. **빌드 파일**: `.wasm`, `csv_converter.js` 등은 `.gitignore`에 포함되어 있으므로 각자 빌드 필요
